use hli::vector::Vector;

use crate::vfc::*;

use crate::EngineState;

pub const _TEST_MAP: &'static [&'static str] = &[
    "################################",
    "#...............#..............#",
    "#...........b.....#............#",
    "####..........#####............#",
    "#...............#..............#",
    "#......###......#..............#",
    "#............#..#..............#",
    "#...............#..............#",
    "#..###..........#..............#",
    "#.........###...#..............#",
    "#...............#..............#",
    "#.......@.......#..............#",
    "#....########...#..............#",
    "#...............#~~.~~.~~.~~.~~#",
    "#...............#..............#",
    "################################",
    "#..............................#",
    "#..............................#",
    "#..............................#",
    "#..............................#",
    "#..............................#",
    "#..............................#",
    "#..............................#",
    "#..............................#",
    "#..............................#",
    "#..............................#",
    "#..............................#",
    "#..............................#",
    "#..............................#",
    "#..............................#",
    "#..............................#",
    "#......................#........",
    "################################",
];

pub const _TEST_MAP_WIDE: &'static [&'static str] = &[
    "################################################################",
    "#......................#.......................................#",
    "#......................#.......................................#",
    "#......................#.......................................#",
    "#......................#.......................................#",
    "#......................#.......................................#",
    "#......................#.......................................#",
    "#.........@............#.......................................#",
    "#......................#.......................................#",
    "#......................#.......................................#",
    "#......................#.......................................#",
    "#......................#.......................................#",
    "#......................#.......................................#",
    "#......................#.......................................#",
    "#......................#.......................................#",
    "#......................#.......................................#",
    "#......................#.......................................#",
    "#......................#.......................................#",
    "#......................#.......................................#",
    "################################################################",
];

pub const _TEST_MAP_ENCLOSED: &'static [&'static str] = &[
    "################################",
    "#......................#........",
    "#......................#........",
    "#..b....%......%....b..#........",
    "#.....############.....#........",
    "#......................#........",
    "#......................#........",
    "#######..........#######........",
    "#......................#........",
    "#............@.........#........",
    "#.....############.....#........",
    "#......................#........",
    "#......................#........",
    "#######..........#######........",
    "#......................#........",
    "#......................#........",
    "#.....############.....#........",
    "#......................#........",
    "#......................#........",
    "################################",
    "#........#~~~~#........#........",
    "#........######........#........",
    "#......................#........",
    "#......................#........",
    "#......................#........",
    "#......................#........",
    "#......................#........",
    "#......................#........",
    "#......................#........",
    "#......................#........",
    "#......................#........",
    "#......................#........",
];

pub const ENDLESS_MODE_MAP: &'static [&'static str] = &[
    "##########....##################",
    "#......................#........",
    "#.......&......&.......#........",
    "#..b................b..#........",
    "#..&..############..&..#........",
    "#......................#........",
    "#..........&...........#........",
    "#######..........#######........",
    "#.......b..&...b.......#........",
    "#..&................&..#........",
    "#.....############.....#........",
    "#...&..............&...#........",
    "#..........&...........#........",
    "#######..........#######........",
    "#........&...&.........#........",
    "#..&........@.......&..#........",
    "#.....############.....#........",
    "#...&..............&...#........",
    "#..........&...........#........",
    "##########~~~~##################",
    "#........#~~~~#........#........",
    "#........######........#........",
    "#..........&...........#........",
    "#......................#........",
    "#......................#........",
    "#......................#........",
    "#......................#........",
    "#......................#........",
    "#......................#........",
    "#........######........#........",
    "#........#%..%#........#........",
    "#........#....#........#........",
];

fn char_to_tile(c: &char) -> Result<TileIndex, ()> {
    Ok(match c {
        '.' | '@' | 'A'..='Z' | 'a'..='z' | '%' => TileIndex(0),
        '&' => TileIndex(1),
        '#' | '~' => TileIndex(*c as u8),
        _ => return Err(()),
    })
}

enum Object {
    Player,
    Enemy(u8),
    Spawner(u8),
}

fn char_to_object(c: &char) -> Option<Object> {
    use Object::*;

    Some(match c {
        '&' | '.' | '#' | '~' => return None,
        '@' => Player,
        'A'..='Z' | 'a'..='z' => Enemy(*c as u8),
        '%' => Spawner(b'b'),
        _ => unreachable!(),
    })
}

pub struct Map {
    player_position: Vector<i32, 2>,
    dimensions: Vector<i32, 2>,
    background_tiles: Vec<TileIndex>,
    enemies: Vec<(u8, Vector<i32, 2>)>,
}

impl Map {
    pub fn test_level() -> Map {
        Map::from_slice_of_strs(ENDLESS_MODE_MAP).unwrap()
    }

    pub fn from_slice_of_strs(data: &[&str]) -> Result<Map, ()> {
        let mut maybe_player_position = None;

        if data.is_empty() {
            return Err(());
        }

        let height = data.len();

        let width = data[0].len();

        if height >= 256 || width >= 256 {
            return Err(());
        }

        let dimensions = Vector([width as i32, height as i32]);

        let mut background_tiles = Vec::with_capacity(width * height);
        let mut enemies = vec![];

        for (yi, row) in data.iter().enumerate() {
            if row.len() != width {
                return Err(());
            }

            for (xi, ch) in row.chars().enumerate() {
                if let Some(obj) = char_to_object(&ch) {
                    let loc = Vector([xi as i32, yi as i32]);

                    match obj {
                        Object::Player => maybe_player_position = Some(loc),
                        Object::Enemy(enemy_ch) => enemies.push((enemy_ch, loc)),
                        //~ Object::Spawner(enemy_ch) => enemies.push((enemy_ch, loc)),
                        Object::Spawner(_enemy_ch) => (),
                    }
                }

                let tile = char_to_tile(&ch)?;

                background_tiles.push(tile);
            }
        }

        if let Some(player_position) = maybe_player_position {
            Ok(Map {
                player_position,
                dimensions,
                background_tiles,
                enemies,
            })
        } else {
            Err(())
        }
    }

    fn index_from_coordinates(&self, x: i32, y: i32) -> usize {
        y as usize * self.width() as usize + x as usize
    }

    pub fn dimensions(&self) -> Vector<i32, 2> {
        self.dimensions
    }

    pub fn width(&self) -> i32 {
        self.dimensions().x()
    }
    /*
        pub fn height(&self) -> i32 {
            self.dimensions().y()
        }
    */
    pub fn player_position(&self) -> Vector<i32, 2> {
        self.player_position
    }

    pub fn enemies(&self) -> &Vec<(u8, Vector<i32, 2>)> {
        &self.enemies
    }

    pub fn draw_map(
        &mut self,
        //~ _game_state: &mut Game,
        engine_state: &mut EngineState,
        //~ bg_pos: Vector<2, i32>,
        //~ map_pos: Vector<2, i32>,
        //~ dim: Vector<2, i32>,
        map_x: i32,
        map_y: i32,
        pos_x: i32,
        pos_y: i32,
        height: i32,
        width: i32,
    ) {
        //~ let [map_x, map_y] = map_pos.0;
        //~ let [bg_x, bg_y] = bg_pos.0;
        //~ let [width, height] = dim.0;

        let pos_x = pos_x % 32;
        let pos_y = pos_y % 32;

        for yi in 0..height {
            for xi in 0..width {
                let bg_x = (pos_x + xi) % 32;
                let bg_y = (pos_y + yi) % 32;

                let mx = map_x + xi;
                let my = map_y + yi;

                let index = self.index_from_coordinates(mx, my);
                let tile = self.background_tiles[index];

                hli::fc::poke_main_bg(&mut engine_state.fc, bg_x as usize, bg_y as usize, tile);
            }
        }
    }
}

//
